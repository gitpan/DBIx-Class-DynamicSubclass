NAME
    DBIx::Class::DynamicSubclass - Convenient way to use dynamic
    subclassing.

SYNOPSIS
        package My::Schema::Game;

        __PACKAGE__->load_components(qw/DynamicSubclass Core/);
        __PACKAGE__->add_column(qw/id name data type/);

        __PACKAGE__->typecast_map(type => {
            1 => 'My::Schema::Game::Online',
            2 => 'My::Schema::Game::Shareware',
            3 => 'My::Schema::Game::PDA',
        });

        $game = $schema->resultset('Game')->new({..., type => 1});
        #  ref $game = 'My::Schema::Game::Online'

        @games = $game->search({type => 2});
        # @games are all of class My::Schema::Game::Shareware

        $game->type(3); # game is now of class My::Schema::Game::PDA

        $game =  $schema->resultset('Game')->new({});
        # or
        $game->type(undef);
        # game is now of type My::Schema::Game

        #Dynamic properties with DBIx::Class::FrozenColumns
        package My::Schema::Game;
        __PACKAGE__->load_components(qw/... FrozenColumns .../);

        package My::Schema::Game::Online;
        use base 'My::Schema::Game';
        __PACKAGE__->add_frozen_columns(data => qw/flash server_host server_port/);

        package My::Schema::Game::Shareware;
        use base 'My::Schema::Game';
        __PACKAGE__->add_frozen_columns(data => qw/price download_url/);

        ...

        $game->type(1); #game would have now additional columns 'flash', 'server_host', etc.
        $game->server_host('...'); #(stored in 'data')

        $game->type(2);
        $game->server_host; #error
        $game->price('$3.00'); #ok

        $game = $rs->new({
            type  => 1,
            flash => 'game.swf',
        }); #ok

        #More flexible way

        package My::Schema::Game;
        __PACKAGE__->typecast_column('type');

        sub classify { #called each time the object gets or losses its 'type'
            my $self = shift;
            #decide which class do you want
            bless $self, $class;
        }

DESCRIPTION
    This plugin implements methodics described here
    "Dynamic_Sub-classing_DBIx::Class_proxy_classes_(AKA_multi-class_object_
    inflation_from_one_table)" in DBIx::Class::Manual::Cookbook.

    DynamicSubclass has 2 ways to work: static defining and dynamic
    defining.

    Static defining is used in most cases. This is when you define

        __PACKAGE__->typecast_map(defining_column => {column_value => 'subclass', ...});

    The plugin preloads all of the subclasses and changes the class of the
    row object when you are creating new object or fetching it from a
    database or changing 'defining_column' value. If the value is not exists
    in the 'typecast_map' then object is blessed into the base class and
    losses all of its additional methods/columns/etc.

    Dynamic defining is when you only say

        __PACKAGE__->typecast_column('defining_column');

    and define a method 'classify' that would bless a row object into proper
    class. This method is called when object is created, fetched or have its
    'defining_column' value changed.

METHODS
  typecast_map
    Arguments: $column, %typecast_hash

    %typecast_hash is a hash with keys equal to possible $column values and
    with subclasses as values.

  classify
    A standart method for static subclassing. You should redefine this
    method in your result source in order to use dynamic subclassing (second
    way).

OVERLOADED METHODS
    new, inflate_result, store_column

